\chapter{Implement\'aci\'o}\label{chapter:implementation}
Ebben a fejezetben a "WatchWithFriends" alkalmazás implementációs folyamatát mutatom be.
\section*{Szerver oldali logika implementálása}
\subsection*{Entity Framework és Data projekt}
Az adatintegritás és az adatmanipuláció kezelésének centralizálása érdekében létrehoztam egy különálló projektcsoportot, amely specifikusan az adatkezelési logika implementációjáért felel. Ebben a dedikált modulban helyeztem el az adatbázis tábláinak sémáját, valamint az adathozzáférési réteget képviselő repository-kat.
\\
A modul architektúrája rugalmas és jól skálázható módon épül fel, köszönhetően az Entity Framework integrációjának. Az Entity Framework ORM (Object-Relational Mapping) képességeit kihasználva, egyszerűsítem és automatizálom az adatbázis műveleteket, csökkentve ezzel az ismétlődő kód és az esetleges hibák számát.
\\
A modell definíciók és az adatbázis kontextus is ebbe a projektcsoportba kerültek, így biztosítva, hogy az adatmodellek és az adatbázis-sémák közötti szoros kapcsolat koherens és könnyen kezelhető maradjon. Az egész rendszer így válik áttekinthetővé és könnyen karbantarthatóvá.
\\
Ezen architektúra alkalmazásával nem csak az adatkezelés egyszerűsödik, de a jövőbeli fejlesztések és bővítések is gördülékenyebben, valamint hatékonyabban valósíthatók meg.
\subsubsection*{Modellek}
A modellek az adatbázisban lévő táblákat reprezentálják, és a kontextus segítségével tudom őket kezelni.
\\
\\
\underline{Péládul a User modell így néz ki:}
\begin{lstlisting}[language=CSharp,style=CSharpBase,caption={User modell}]
public class User
{
    public Guid Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
    public string? PasswordHash { get; set; }
    public string? Salt { get; set; }
    public DateTime BirthDate { get; set; }
    public Guid? ImageId { get; set; }
}
\end{lstlisting}
\vspace{1em}
A táblákat reprezentáló modelleknek minden tulajdonsága egy oszlop az adatbázisban.
A modellekben találhatóak navigációs tulajdonságok is, amelyek segítségével a modellek közötti kapcsolatokat tudom megvalósítani.
A táblákat a migrációk segítségével tudom létrehozni, amelyek a modellek alapján generálódnak, majd az update-database parancs kiadásával tudom őket alkalmazni az adatbázison.

\subsubsection*{Kontextusok}
A komplex adatkezelési igényeket kielégítendő, a szoftverarchitektúrámban két különálló adatbázis-kontextust implementáltam. Az első, a "WatchWithFriendsDBContext", főként a felhasználói információkat és a képmegosztás funkciókat kezeli. Ennek az adatállománynak az SQL Server adatbázisban való tárolása biztosítja az adatintegritást és a tranzakcionális biztonságot.

A másik kontextus, a "RoomsDBContext", azonban egészen más jellegű adatokat adminisztrál: itt a szobák és a videók információit kezelem. Erre az adatrétegre egy InMemory adatbázist alkalmazok. Ezzel a megoldással két fontos célt érek el. Egyrészt, az InMemory adatbázis lehetővé teszi a gyors és rugalmas adatmanipulációt, optimális azokhoz a szobákhoz és videókhoz, amelyek volatilis jelleggel bírnak és nem szükségesek hosszútávú tárolásra. Másrészt, a szerver leállításával automatikusan törlődnek ezek az adatok, így nincs szükség manuális karbantartásra ezen a fronton.

A két különböző kontextus párhuzamos működése lehetővé teszi az adatrétegek elkülönítését és a szoftver komponenseinek független skálázhatóságát, miközben az adatintegritás és a rendelkezésre állás is megmarad.
\\
\\
\underline{Például a WatchWithFriendsDBContext így néz ki:}
\begin{lstlisting}[language=CSharp,style=CSharpBase,caption={WatchWithFriendsDBContext}]
public class WatchWithFriendsDBContext : DbContext
{
    public WatchWithFriendsDBContext
    (DbContextOptions<WatchWithFriendsDBContext> options) 
    : base(options)
    { }

    public DbSet<User> Users { get; set; }
    public DbSet<Image> Images { get; set; }
}
\end{lstlisting}
\vspace{1em}
\subsubsection*{Repository réteg}
A repository-k segítségével tudom kezelni az adatbázist, és a modelleket.
\\
\underline{Például a UserRepository így néz ki:}
\begin{lstlisting}[language=CSharp,style=CSharpBase,caption={User Repository}]
public class UserRepository : IUserRepository
{
    private readonly WatchWithFriendsDBContext _context;

    public UserRepository(WatchWithFriendsDBContext context)
    {
        _context = context;
    }

    public async Task<User> GetUserById(Guid id)
    {
        return await _context.Users
            .Include(u => u.Image)
            .FirstOrDefaultAsync(u => u.Id == id);
    }

    //tobbi metodus
}
\end{lstlisting}
\vspace{1em}
Fontosnak tartottam az async műveletek használatát, mert így a szerver nem blokkolódik, és a kliensek is gyorsabban kapják meg a válaszokat.
\subsubsection*{Extension metódus}
Létrehoztam egy extension metódust, amely segítségével tudom a repository-kat a DI konténerbe regisztrálni, illetve a kontextusokat létrehozni.
\begin{lstlisting}[language=CSharp,style=CSharpBase]
public static void WatchWithFriendsData(
    this IServiceCollection services,
    DataBaseType dataBaseType)
{
    var IConfigugration = services
                        .BuildServiceProvider()
                        .GetRequiredService<IConfiguration>();
    var connstring = IConfigugration
                    .GetConnectionString("watchwithfriends");
    services.AddDbContext<WatchWithFriendsDBContext>(
    options =>
    {
        options.UseSqlServer(connstring);
    });
    services.AddDbContext<RoomsDBContext>(options =>
    {
        options.UseInMemoryDatabase("rooms")
    });
    services.AddScoped<IUserRepository, UserRepository>();
    //tobbi repository
}

\end{lstlisting}
\vspace{1em}
\subsection*{Szerver oldali logika és végpontok}
A szerver oldali logika az alkalmazás "háttere", itt történik minden, ami az adatok manipulációjával, az üzleti szabályok végrehajtásával és az erőforrások menedzsmentjével kapcsolatos. A végpontok (endpoints) a szerver oldali logika speciális részei, amelyek meghatározzák, hogy a kliens hogyan interakciózik a szerverrel.
\subsubsection*{Service réteg}
A service réteg általában az üzleti logikát tartalmazza egy alkalmazásban. Ebben a rétegben találhatóak meg azok a függvények és metódusok, amelyek nem közvetlenül kapcsolódnak az adatok eléréséhez vagy a felhasználói felülethez, hanem inkább az alkalmazás "logikáját" képezik.
\\
\\
\underline{Például a UserService így néz ki:}
\begin{lstlisting}[language=CSharp,style=CSharpBase,caption={User Service}]
public class UserService : IUserService
{
    private readonly IUserRepository _userRepository;

    public UserService(IUserRepository userRepository)
    {
        _userRepository = userRepository; // DI
    }

    public async Task<User> GetUserById(Guid id)
    {
        return await _userRepository.GetUserById(id);
    }

    //tobbi metodus
}
\end{lstlisting}
\vspace{1em}
\subsubsection*{Controller réteg}
A controller réteg a végpontokat kezeli. A végpontok a kliens és a szerver közötti kommunikáció alapját képezik. A végpontok meghatározzák, hogy a kliens hogyan interakciózik a szerverrel. A végpontok a kliens kéréseit fogadják, és válaszokat generálnak.
\\
\\
\underline{Például a UserController így néz ki:}
\begin{lstlisting}[language=CSharp,style=CSharpBase,caption={User Controller}]
[ApiController]
[Route("[controller]")]
public class UserController : ControllerBase
{
private readonly IUserService _userService;

public UserController(IUserService userService)
{
_userService = userService; // DI
}

[HttpGet("{id}")]
public async Task<IActionResult> GetUserById(Guid id)
{
        var user = await _userService.GetUserById(id);
        if (user == null)
        {
                return NotFound();
            }
        return Ok(user);
    }

//tobbi vegpont
}
\end{lstlisting}