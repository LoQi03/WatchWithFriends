\chapter{Implement\'aci\'o}\label{chapter:implementation}
Ebben a fejezetben a "WatchWithFriends" alkalmazás implementációs folyamatát mutatom be.
\section*{Szerver oldali logika}
\subsection*{Entity Framework és Data projekt}
Az adatintegritás és az adatmanipuláció kezelésének centralizálása érdekében létrehoztam egy különálló projektcsoportot, amely specifikusan az adatkezelési logika implementációjáért felel. Ebben a dedikált modulban helyeztem el az adatbázis tábláinak sémáját, valamint az adathozzáférési réteget képviselő repository-kat.
\\
A modul architektúrája rugalmas és jól skálázható módon épül fel, köszönhetően az Entity Framework integrációjának. Az Entity Framework ORM (Object-Relational Mapping) képességeit kihasználva, egyszerűsítem és automatizálom az adatbázis műveleteket, csökkentve ezzel az ismétlődő kód és az esetleges hibák számát.
\\
A modell definíciók és az adatbázis kontextus is ebbe a projektcsoportba kerültek, így biztosítva, hogy az adatmodellek és az adatbázis-sémák közötti szoros kapcsolat koherens és könnyen kezelhető maradjon. Az egész rendszer így válik áttekinthetővé és könnyen karbantarthatóvá.
\\
Ezen architektúra alkalmazásával nem csak az adatkezelés egyszerűsödik, de a jövőbeli fejlesztések és bővítések is gördülékenyebben, valamint hatékonyabban valósíthatók meg.
\subsubsection*{Modellek}
A modellek az adatbázisban lévő táblákat reprezentálják, és a kontextus segítségével tudom őket kezelni.
\\
\\
\underline{Péládul a User modell így néz ki:}
\begin{lstlisting}[language=CSharp,style=CSharpBase,caption={User modell}]
public class User
{
    public Guid Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
    public string? PasswordHash { get; set; }
    public string? Salt { get; set; }
    public DateTime BirthDate { get; set; }
    public Guid? ImageId { get; set; }
}
\end{lstlisting}
\vspace{1em}
A táblákat reprezentáló modelleknek minden tulajdonsága egy oszlop az adatbázisban.
A modellekben találhatóak navigációs tulajdonságok is, amelyek segítségével a modellek közötti kapcsolatokat tudom megvalósítani.
A táblákat a migrációk segítségével tudom létrehozni, amelyek a modellek alapján generálódnak, majd az update-database parancs kiadásával tudom őket alkalmazni az adatbázison.

\subsubsection*{Kontextusok}
A komplex adatkezelési igényeket kielégítendő, a szoftverarchitektúrámban két különálló adatbázis-kontextust implementáltam. Az első, a "WatchWithFriendsDBContext", főként a felhasználói információkat és a képmegosztás funkciókat kezeli. Ennek az adatállománynak az SQL Server adatbázisban való tárolása biztosítja az adatintegritást és a tranzakcionális biztonságot.

A másik kontextus, a "RoomsDBContext", azonban egészen más jellegű adatokat adminisztrál: itt a szobák és a videók információit kezelem. Erre az adatrétegre egy InMemory adatbázist alkalmazok. Ezzel a megoldással két fontos célt érek el. Egyrészt, az InMemory adatbázis lehetővé teszi a gyors és rugalmas adatmanipulációt, optimális azokhoz a szobákhoz és videókhoz, amelyek volatilis jelleggel bírnak és nem szükségesek hosszútávú tárolásra. Másrészt, a szerver leállításával automatikusan törlődnek ezek az adatok, így nincs szükség manuális karbantartásra ezen a fronton.

A két különböző kontextus párhuzamos működése lehetővé teszi az adatrétegek elkülönítését és a szoftver komponenseinek független skálázhatóságát, miközben az adatintegritás és a rendelkezésre állás is megmarad.
\\
\\
\underline{Például a WatchWithFriendsDBContext így néz ki:}
\begin{lstlisting}[language=CSharp,style=CSharpBase,caption={WatchWithFriendsDBContext}]
public class WatchWithFriendsDBContext : DbContext
{
    public WatchWithFriendsDBContext
    (DbContextOptions<WatchWithFriendsDBContext> options) 
    : base(options)
    { }

    public DbSet<User> Users { get; set; }
    public DbSet<Image> Images { get; set; }
}
\end{lstlisting}
\vspace{1em}
\subsubsection*{Repository réteg}
A repository-k segítségével tudom kezelni az adatbázist, és a modelleket.
\\
\underline{Például a UserRepository így néz ki:}
\begin{lstlisting}[language=CSharp,style=CSharpBase,caption={User Repository}]
public class UserRepository : IUserRepository
{
    private readonly WatchWithFriendsDBContext _context;

    public UserRepository(WatchWithFriendsDBContext context)
    {
        _context = context;
    }

    public async Task<User> GetUserById(Guid id)
    {
        return await _context.Users
            .Include(u => u.Image)
            .FirstOrDefaultAsync(u => u.Id == id);
    }

    //tobbi metodus
}
\end{lstlisting}
\vspace{1em}
Fontosnak tartottam az async műveletek használatát, mert így a szerver nem blokkolódik, és a kliensek is gyorsabban kapják meg a válaszokat.
\subsubsection*{Extension metódus}
Létrehoztam egy extension metódust, amely segítségével tudom a repository-kat a DI konténerbe regisztrálni, illetve a kontextusokat létrehozni.
\begin{lstlisting}[language=CSharp,style=CSharpBase]
public static void WatchWithFriendsData(
    this IServiceCollection services,
    DataBaseType dataBaseType)
{
    var IConfigugration = services
                        .BuildServiceProvider()
                        .GetRequiredService<IConfiguration>();
    var connstring = IConfigugration
                    .GetConnectionString("watchwithfriends");
    services.AddDbContext<WatchWithFriendsDBContext>(
    options =>
    {
        options.UseSqlServer(connstring);
    });
    services.AddDbContext<RoomsDBContext>(options =>
    {
        options.UseInMemoryDatabase("rooms")
    });
    services.AddScoped<IUserRepository, UserRepository>();
    //tobbi repository
}

\end{lstlisting}
\vspace{1em}
\subsection*{Szerver oldali logika és végpontok}
A szerver oldali logika az alkalmazás "háttere", itt történik minden, ami az adatok manipulációjával, az üzleti szabályok végrehajtásával és az erőforrások menedzsmentjével kapcsolatos. A végpontok (endpoints) a szerver oldali logika speciális részei, amelyek meghatározzák, hogy a kliens hogyan interakciózik a szerverrel.
\subsubsection*{Service réteg}
A service réteg általában az üzleti logikát tartalmazza egy alkalmazásban. Ebben a rétegben találhatóak meg azok a függvények és metódusok, amelyek nem közvetlenül kapcsolódnak az adatok eléréséhez vagy a felhasználói felülethez, hanem inkább az alkalmazás "logikáját" képezik.
\\
\\
\underline{Például a UserService így néz ki:}
\begin{lstlisting}[language=CSharp,style=CSharpBase,caption={User Service}]
public class UserService : IUserService
{
    private readonly IUserRepository _userRepository;

    public UserService(IUserRepository userRepository)
    {
        _userRepository = userRepository; // DI
    }

    public async Task<User> GetUserById(Guid id)
    {
        return await _userRepository.GetUserById(id);
    }

    //tobbi metodus
}
\end{lstlisting}
\vspace{1em}
\subsubsection*{Controller réteg}
A controller réteg a végpontokat kezeli. A végpontok a kliens és a szerver közötti kommunikáció alapját képezik. A végpontok meghatározzák, hogy a kliens hogyan interakciózik a szerverrel. A végpontok a kliens kéréseit fogadják, és válaszokat generálnak.
\\
\\
\underline{Például a UserController így néz ki:}
\begin{lstlisting}[language=CSharp,style=CSharpBase,caption={User Controller}]
[ApiController]
[Route("[controller]")]
public class UserController : ControllerBase
{
private readonly IUserService _userService;

public UserController(IUserService userService)
{
_userService = userService; // DI
}

[HttpGet("{id}")]
public async Task<IActionResult> GetUserById(Guid id)
{
        var user = await _userService.GetUserById(id);
        if (user == null)
        {
                return NotFound();
            }
        return Ok(user);
    }

//tobbi vegpont
}
\end{lstlisting}

\section*{Kliens oldali logika}
\subsection*{React projekt}
A kliens oldali logika a felhasználói felületet és a felhasználói interakciókat kezeli. A kliens oldali kód gyakran aszinkron módon kommunikál a szerverrel, hogy adatokat kérjen vagy küldjön.
Ezen adatok küldésére API hívásokat használok. Az API hívásokat a React alkalmazásban egy axios nevű könyvtárral valósítottam meg.
Az axios \cite[]{axios} egy HTTP kliens, amely lehetővé teszi a kérések küldését a szervernek, és a válaszok fogadását.
Az axios beállításait egy külön fájlban tárolom, így könnyen tudom őket módosítani.
\\
\\
\underline{Például a axios beállításai így néznek ki:}
\begin{lstlisting}[style=es6,caption={Axios beállítások}]
    import axios from 'axios';
    import * as AppConfig from './AppConfig';

    export const httpClient = axios.create({
        baseURL: AppConfig.GetConfig().apiUrl,
        headers: {
            'Access-Control-Allow-Origin': '*',
            'Content-Type': 'application/json',
            Accept: 'application/json',
        },
    });

    export const updateAuthorizationHeader = () => {
        const newToken = localStorage.getItem('token');
        httpClient.defaults.headers.common["Authorization"] = newToken ?
         `Bearer ${newToken}` : "";
    };
\end{lstlisting}
\vspace{1em}
Itt látható, hogy a kéréseknek milyen fejlécei lesznek, illetve hogy milyen URL-re küldjük a kéréseket, ezt a httpClient-nek adom meg, majd ezt használom a kérések küldésére.
Létrehoztam egy függvényt, amely segítségével tudom a kérésekhez hozzáadni a token-t, amely a felhasználó azonosítására szolgál.
A külömböző env-ekhez különböző beállításokat tudok megadni, így a fejlesztés során a fejlesztői környezetben a localhost-ra küldöm a kéréseket, a tesztelés során a teszt szerverre, a production környezetben pedig a production szerverre.
\\
\\
\underline{Konfigurációs fájl:}
\begin{lstlisting}[style=es6,caption={Konfigurációs fájl}]
    import joi from "joi";

    interface AppConfig {
        apiUrl: string;
    }
    
    export const config: AppConfig = {
        apiUrl: import.meta.env.VITE_WATCH_2_GETHER_BACKEND_ADDRESS ??
        "https://localhost:7165/",
    }
    
    const schema = joi.object({
        apiUrl: joi.string().required(),
    });
    
    export function GetConfig(): AppConfig {
        const { error, value } = schema.validate(config);
        if (error) {
            throw new Error(`Config validation error: ${error.message}`);
        }
        else {
            return value;
        }
    }
\end{lstlisting}
\vspace{1em}
Az env változók validására a joi \cite[]{joi} nevű könyvtárat használom, amely segítségével tudom a változókat ellenőrizni, hogy megfelelnek-e a várt típusnak, illetve, hogy megvannak-e adva.

\subsection*{API services}
Az API services rétegben találhatóak meg a különböző API végpontokat kezelő függvények.
\\
\underline{Például a UserService így néz ki:}
\begin{lstlisting}[style=es6,caption={User Service}]
    import { httpClient } from "../HttpClient";
    import { UserDto } from "../models/userDto";
    
    export const getUserById = async (id: string):
    Promise<AxiosResponse<UserDto>> => {
    const response = await httpClient.get<UserDto>(`Users/${id}`);
    return response;
};

\end{lstlisting}
\vspace{1em}
Minden függvény egy API végpontot hív meg, és a választ visszaadja.
A függvényeket a komponensekben használom, ahol a választ feldolgozom, és a megjelenítést végzem el.
Csak a Pages mappában található komponensekben használok API hívásokat, a többi komponensben a Props-ok vagy Context API segítségével kapom meg az adatokat.
\subsection*{Router}
A Router segítségével tudom a különböző oldalakat megjeleníteni.
\\
\\
\underline{Például a Router így néz ki:}
\begin{lstlisting}[style=es6,caption={Router}]
    <BrowserRouter>
    <Navbar />
    <CommonSrtyles.PageContainer>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/rooms" element={<RoomsPage />} />
        <Route path="/profile" element={<ProfilePage />} />
        <Route path="/friends" element={<FriendsPage />} />
        <Route path="/room/:id" element={<RoomPageWithProvider />} />
      </Routes>
    </CommonSrtyles.PageContainer>
  </BrowserRouter>
\end{lstlisting}
\vspace{1em}
A Routes és Route komponensek a React Router-ben használatosak, és alapvetően az alkalmazás útvonalainak (routes) menedzselésére szolgálnak. Itt egy kis áttekintés a fő komponensekről és tulajdonságokról:
\subsubsection*{Routes komponense}
Ez a komponens az a "konténer", amiben a különböző Route komponenseket helyezzük el. Gyakorlatilag ez kezeli azt, hogy melyik Route komponens aktív egy adott pillanatban.
\subsubsection*{Route komponens}
A Route komponensek felelnek a különböző útvonalakért. Két fő tulajdonságuk van:
\\
\\
\underline{path:}
\\
Ez határozza meg, hogy milyen URL címnél aktíválódjon a Route. Például, ha a path="/about", akkor a /about URL-nél fog betöltődni az adott Route.
\\
\\
\underline{element:}
\\
Ez a tulajdonság tartalmazza azt a komponenst, ami meg fog jelenni, amikor az adott Route aktív. Tehát ha a path="/about" és az element={<About />}, akkor az About komponens fog megjelenni, amikor az /about URL-re navigálunk.
\subsection*{Komponensek}
A React komponensek a UI logikájának egységei, és lehetnek függvény vagy osztály alapúak. Függvényes komponensek egyszerűbbek és könnyebben kezelhetőek, míg az osztály alapúak sokkal több beépített metódust és ciklusfüggvényt kínálnak.
A komponenseknek tulajdonságai (props) amivel a komponensek közötti adatáramlást valósítottam meg.
A komponenseket alkomponensekre bontottam, hogy a kód minél jobban átlátható legyen, és a komponensek újra felhasználhatóak legyenek.
Ezt a  styled-components \cite[]{styled-components} könyvtár segítségével készítettem, amely lehetővé teszi a CSS kódok beágyazását a komponensekbe.
\\
\\
\underline{Példa a styled-components használatára:}
\begin{lstlisting}[style=es6,caption={Styled-components}]
import styled from "styled-components";

export const RoomListItemHeader = styled.div`
    font-size: 30px;
    font-weight: bold;
    margin-left: 15px;
    margin-top: 10px;
`;

\end{lstlisting}
\vspace{1em}
Így egyszerűen adom meg a komponensek stílusát, és a komponensek újra felhasználhatóak lettek.
Illetve ezekből a komponensekből összeállt egy nagyobb komponens.
\\
\\
\begin{lstlisting}[style=es6,caption={RoomListItem komponens}]
export const RoomListItem = (props: RoomListItemProps): JSX.Element => {
    //tobbi kod
    return (
    <Styles.RoomListItemContainer onClick={join}>
        <Styles.RoomListItemContentContainer>
            <Styles.RoomListItemImage
            src={
            `${AppConfig.GetConfig().apiUrl}Users/${props.creatorId}/image`
                }
                />
            <Styles.RoomListItemHeader>
                {props.name}
            </Styles.RoomListItemHeader>
            <Styles.RoomListItemInfo>
                <div>Creator: {creator?.name}</div>
                <Styles.RomListItemMembers><Person2Icon />
                    {" " + props.userCount} 
                </Styles.RomListItemMembers>
            </Styles.RoomListItemInfo>
        </Styles.RoomListItemContentContainer>
    </Styles.RoomListItemContainer>
    )
};
\end{lstlisting}
\vspace{1em}
\subsection*{Context API}
Azokat az adatokat amelyeket több komponensben is használok, a Context API-val valósítottam meg.
Az alkalmazásban a felhasználói adatokat és a szobákkal kapcsolatos adatokat is a Context API-al valósítottam meg.
\\
\\
\underline{Példa a Context API használatára:}
\begin{lstlisting}[style=es6,caption={Context API}]
    import { createContext, useState } from "react";

    //Context API inicializalasa
    
    interface AuthContextType {
        //adat es setter
    }

    export const AuthContext = createContext<AuthContextType | null>(null);

    //Context API Provider

    export const AuthProvider = ({ children }:
     { children: React.ReactNode }) => {
        //adat es setter
        return (
            <AuthContext.Provider
                value={{
                    //adat es setter
                }}
            >
                {children}
            </AuthContext.Provider>
        );
    };

    //Context API hasznalata
    const authContext = useContext(AuthContext);
\end{lstlisting}
\vspace{1em}
